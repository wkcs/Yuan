# Sema 模块文档：表达式类型推断与验证

本文档详细描述了 Yuan 编译器语义分析阶段（Sema）对表达式（Expr）的处理逻辑。表达式分析是 Sema 中最复杂的任务之一，其核心目标是：**推断表达式的类型，检查操作合法性，并将结果类型安全地缓存到 AST 节点中。**

入口函数为 `Sema::analyzeExpr(Expr* expr)`。

## 1. 字面量与基础标识符

### 1.1 字面量 (Literals)
- **整数 (`IntegerLiteralExpr`)**: 默认推断为 `i32`。如果存在显式的类型后缀（如 `100u8`, `42i64`），则直接推断为对应的内置整数类型。
- **浮点数 (`FloatLiteralExpr`)**: 默认推断为 `f64`。若有后缀（如 `3.14f32`）则按后缀处理。
- **布尔值 (`BoolLiteralExpr`)**: `true` 和 `false` 永远推断为 `bool`。
- **字符/字符串**: 单引号字符推断为 `char`（或特定宽度的整数），双引号推断为 `str`（内部表现为 Slice 或胖指针）。
- **None**: 初始被特殊推断为未决 Optional（如 `?void` 或特殊的底层类型），后续在参与赋值或函数调用时，会通过 `checkTypeCompatible` 的自动转换规则将其“降级”并适配到具体的 `?T`。

### 1.2 标识符引用 (`IdentifierExpr`)
- 触发 `SymbolTable::lookup()`，向外层层追溯作用域。
- 若找不到符号，产生 `err_undeclared_identifier` 诊断。
- 若找到，读取符号上的 `Type`，同时将其关联的声明节点（`Decl*`）注入到 `ResolvedDecl` 中（供 LSP 的 Hover/Definition 使用以及 CodeGen 后续生成地址）。

## 2. 运算与赋值

### 2.1 一元运算 (`UnaryExpr`)
- **取址借用 (`&`)**: 操作数必须是“左值”(lvalue) 或者允许隐式借用的特殊类型（如对数组进行切片借用时）。表达式类型变为 `&T`。
- **可变借用 (`&mut`)**: 操作数必须是 lvalue，**且**符号本身必须是可变的（例如声明为 `var mut` 而非 `let` / `const`）。表达式类型变为 `&mut T`。
- **解引用 (`*`)**: 操作数必须是引用（`&T` 或 `&mut T`）或裸指针。表达式类型解包为 `T`。
- **逻辑非 (`!`)**: 仅作用于 `bool`。
- **算术负 (`-`)**: 仅作用于有符号整数或浮点数。

### 2.2 二元运算 (`BinaryExpr`)
涵盖算术 (`+`, `-`, `*`, `/`)、比较 (`==`, `>`, `<=`)、逻辑 (`&&`, `||`) 和位运算。
- **类型适配**: Sema 会尝试获取两侧操作数的公共类型（`getCommonType`）。
  - 若一侧是无后缀的整数字面量，另一侧是具体的 `i64`，Sema 会自动将字面量适配为 `i64`。
- **约束检查**:
  - 算术运算要求两侧为兼容的数值类型。
  - 比较运算要求两侧支持可比性，返回 `bool`。
  - `orelse` 操作符要求左侧为 `?T`（Optional），右侧为 `T` 或 `?T`。如果左侧为 `None`，则使用右侧值，整个表达式结果为 `T` 或 `?T`。

### 2.3 赋值表达式 (`AssignExpr`)
- **左值检查 (`checkAssignable`)**: 赋值目标不能是字面量、函数调用返回值（按值返回的情况）等临时对象。
- **可变性检查 (`checkMutable`)**: 目标对象的源头必须被标记为可变（比如非 `const`，或者不是不可变引用）。
- **兼容性检查**: 右侧表达式的类型必须能满足左侧预期，调用 `checkTypeCompatible` 验证。

## 3. 成员访问与调用

### 3.1 成员访问 (`MemberExpr`)
格式如 `obj.field` 或 `std.fmt`。
- **模块成员**: 若 `obj` 被解析为 `ModuleType`，则在其内部导出符号中查找 `field`。
- **结构体字段**: 若 `obj` 为结构体（或其引用/指针，Sema 会执行自动解引用），则在结构体声明中查找字段，返回字段的声明类型。
- **枚举关联函数**: 若通过 `Enum::Variant` 访问。
- **方法解析**: 若字段不存在，Sema 可能会暂存该表达式，直到其被用作 `CallExpr` 的基底时，再去 `ASTContext` 或 `ImplTraitMap` 中执行方法（Method）的解析与签名匹配。

### 3.2 调用表达式 (`CallExpr`)
函数调用分析是 `analyzeExpr` 最具挑战性的部分：
1. **基底类型验证**: 检查 Callee 是否具有 `FunctionType` 或是一个结构体/枚举的构造函数。
2. **方法调用改造**: 如果 Callee 是一个成员方法调用（`obj.method()`），Sema 会在内部校验 `self` 的传递是否合法（是否需要自动加上 `&` 或 `&mut`，并对 `obj` 的可变性进行二次校验）。
3. **参数数量匹配**: 校验传入实参个数是否匹配，若函数定义了默认参数，Sema 需确认必填参数已全覆盖；若含有变长参数 `...`，则将多余参数打包类型校验。
4. **泛型推导**:
   - 若 Callee 是泛型函数，Sema 根据传入的实际参数（`actual`）类型，逆向推导（`unifyGenericTypes`）出每一个泛型参数 `T`。
   - 推导完成后，Sema 会在内部实例化一个针对当前类型的签名，并确保 Trait 约束满足（调用 `checkTraitBound`）。
5. **返回值赋值**: 最终 `CallExpr` 的类型被设为函数/方法的返回类型。

## 4. 特殊表达式与语法糖

### 4.1 错误处理表达式
在 Yuan 中，错误总是作为类型系统的一部分 (`!T`) 存在，不抛出异常。
- **错误传播 (`expr!`)**:
  - `expr` 的推断类型必须是一个 `!T`（或者说 `ErrorType` 包装的 `T`）。
  - Sema 会校验当前所在的函数本身是否具有 `canError`（返回 `!U`）的签名。如果不具备，则禁止使用 `!` 传播错误。
  - 本表达式的返回类型推断为底层的安全类型 `T`。
- **错误捕获 (`expr -> err { body }`)**:
  - 同样要求 `expr` 为 `!T`。
  - Sema 会开辟一个隐式作用域，将名为 `err` 的变量注入进去（其类型被设为系统级枚举 `SysError`）。
  - `body` 中的最后一条语句必须执行处理，如果 `body` 分支和成功分支需要对齐，则会对它们的类型执行 `getCommonType` 汇聚。
  - 整个表达式的推导类型为 `T`。

### 4.2 构造表达式 (`StructExpr`, `ArrayExpr`, `TupleExpr`)
- **结构体构造**: 对照目标结构体的字段列表，检查是否缺少未赋默认值的字段，或是否存在未定义的字段，同时逐一检查字段类型兼容性。
- **数组构造 (`[a, b, c]`)**: 推断首个元素的类型，并强制后续元素全部保持一致；或对于 `[val; N]` 形式，提取常量 `N` 生成具体的 `ArrayType`。
- **元组构造 (`(a, b)`)**: 依次记录各位置的类型，拼装出 `TupleType`。

### 4.3 闭包表达式 (`ClosureExpr`)
- 闭包可以捕获外部环境（捕获逻辑在 Sema 阶段进行初步的可视性验证，并在后续传递给 CodeGen 生成环境块）。
- 闭包拥有独立的局部作用域（`Function` 级别），参数类型若省略则需要根据使用上下文进行双向类型推断（Bidirectional Type Inference，在目前实现中具有一定限制）。

## 5. 类型写回约定
所有成功的推断最终都必须调用 `expr->setType(Type*)` 将类型持久化。对于带有标识符性质的节点，还要将 `Symbol` 里的关联信息绑定过去，这是整个后续代码生成不出错的前提保障。