// 错误传递表达式测试用例

// 可能返回错误的函数
func divide(a: i32, b: i32) -> !i32 {
    if b == 0 {
        return SysError.DivisionByZero
    }
    return a / b
}

func parse_number(s: str) -> !i32 {
    if s.len() == 0 {
        return SysError.ParseError { message: "Empty string" }
    }
    return 42  // 简化实现
}

func read_file(path: str) -> !String {
    if path.len() == 0 {
        return SysError.FileNotFound { path: path }
    }
    return String.from("file content")
}

func test_error_propagation() {
    // 基本错误传递
    var result1: i32 = divide(10, 2)!
    var result2: i32 = parse_number("42")!
    
    // 链式错误传递
    var content: String = read_file("test.txt")!
    var number: i32 = parse_number(content.as_str())!
    var divided: i32 = divide(number, 2)!
    
    // 错误处理块
    var safe_result: i32 = divide(10, 0)! -> err {
        return 0
    }
    
    // 带错误信息的处理
    var handled_result: i32 = parse_number("")! -> err {
        const io = @import("std").io
        io.println(err.message())
        io.println(err.func_name)
        io.println(err.file)
        io.println(err.line)
        return -1
    }
    
    // 复杂错误传递链
    var complex_result: i32 = process_data("input.txt")!
    
    // 条件错误传递
    var conditional: i32 = if should_process() {
        divide(20, 4)!
    } else {
        0
    }
    
    // 循环中的错误传递
    var numbers = [1, 2, 0, 4, 5]
    for num in numbers {
        var result: i32 = divide(100, num)! -> err {
            continue  // 跳过错误情况
        }
    }
    
    // match 中的错误传递
    var option_result = match get_divisor() {
        value => divide(10, value)!,
        None => 0,
    }
}

func process_data(path: str) -> !i32 {
    var content: String = read_file(path)!
    var number: i32 = parse_number(content.as_str())!
    return divide(number, 2)!
}

func should_process() -> bool {
    return true
}

func get_divisor() -> ?i32 {
    return 5
}

// 简化的可变参数函数（移除 @ 语法）
func sum_from_strings(strings: [str]) -> !i32 {
    var total: i32 = 0
    for s in strings {
        var num: i32 = parse_number(s)!
        total += num
    }
    return total
}

// 泛型函数的错误传递
func try_convert<T, U>(value: T, converter: func(T) -> !U) -> !U {
    return converter(value)!
}

// 异步函数的错误传递（如果支持）
async func async_divide(a: i32, b: i32) -> !i32 {
    return divide(a, b)!
}

// 闭包中的错误传递
func test_closure_errors() {
    var error_closure = func(x: i32) -> !i32 {
        return divide(100, x)!
    }
    
    var result: i32 = error_closure(5)! -> err {
        return 0
    }
}