/// \file snake_window.yu
/// \brief 基于原生 GUI 后端（FFI）的窗口版贪吃蛇示例。

const std = @import("std")
const gui = std.gui
const println = std.io.println
const format = std.fmt.format

const DIR_UP = 0
const DIR_RIGHT = 1
const DIR_DOWN = 2
const DIR_LEFT = 3

const CELL = 24
const BOARD_X = 16
const BOARD_Y = 56
const COLS = 24
const ROWS = 18

const COLOR_BG = 0x0f172au64
const COLOR_BOARD = 0x111827u64
const COLOR_SNAKE = 0x22c55eu64
const COLOR_HEAD = 0x84cc16u64
const COLOR_FOOD = 0xef4444u64
const COLOR_TEXT = 0xe2e8f0u64
const COLOR_DANGER = 0xf97316u64

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    func equals(&self, other: Point) -> bool {
        return self.x == other.x && self.y == other.y
    }
}

struct Lcg {
    state: u64,
}

impl Lcg {
    func new(seed: u64) -> Lcg {
        return Lcg { state: seed }
    }

    func next_u32(&mut self) -> u32 {
        self.state = self.state * 6364136223846793005u64 + 1u64
        return (self.state >> 32u64) as u32
    }

    func next_i32(&mut self, bound: i32) -> i32 {
        if bound <= 0 {
            return 0
        }
        return (self.next_u32() % (bound as u32)) as i32
    }
}

func is_opposite(a: i32, b: i32) -> bool {
    if a == DIR_UP && b == DIR_DOWN {
        return true
    }
    if a == DIR_DOWN && b == DIR_UP {
        return true
    }
    if a == DIR_LEFT && b == DIR_RIGHT {
        return true
    }
    if a == DIR_RIGHT && b == DIR_LEFT {
        return true
    }
    return false
}

struct SnakeGame {
    snake: std.collections.Vec<Point>,
    food: Point,
    dir: i32,
    alive: bool,
    score: i32,
    rng: Lcg,
}

impl SnakeGame {
    func create(seed: u64) -> Self {
        var snake: std.collections.Vec<Point> = std.collections.Vec.new()
        var cx: i32 = COLS / 2
        var cy: i32 = ROWS / 2
        snake.push(Point { x: cx - 1, y: cy })
        snake.push(Point { x: cx, y: cy })
        snake.push(Point { x: cx + 1, y: cy })

        return SnakeGame {
            snake: snake,
            food: Point { x: 1, y: 1 },
            dir: DIR_RIGHT,
            alive: true,
            score: 0,
            rng: Lcg.new(seed),
        }
    }

    func reset(&mut self, seed: u64) {
        self.snake.free()
        var nx = SnakeGame.create(seed)
        self.snake = nx.snake
        self.food = nx.food
        self.dir = nx.dir
        self.alive = nx.alive
        self.score = nx.score
        self.rng = nx.rng
    }

    func free(&mut self) {
        self.snake.free()
    }

    func head(&self) -> Point {
        return self.snake.last()
    }

    func contains_snake(&self, p: Point) -> bool {
        var i: usize = 0u64
        while i < self.snake.len {
            if self.snake.get(i).equals(p) {
                return true
            }
            i += 1u64
        }
        return false
    }

    func spawn_food(&mut self) {
        loop {
            var p = Point {
                x: self.rng.next_i32(COLS),
                y: self.rng.next_i32(ROWS),
            }
            if !self.contains_snake(p) {
                self.food = p
                return
            }
        }
    }

    func set_dir(&mut self, ndir: i32) {
        if !is_opposite(self.dir, ndir) {
            self.dir = ndir
        }
    }

    func step(&mut self) {
        if !self.alive {
            return
        }

        var h: Point = self.head()
        var nh: Point = h
        if self.dir == DIR_UP {
            nh.y -= 1
        } elif self.dir == DIR_RIGHT {
            nh.x += 1
        } elif self.dir == DIR_DOWN {
            nh.y += 1
        } else {
            nh.x -= 1
        }

        if nh.x < 0 || nh.x >= COLS || nh.y < 0 || nh.y >= ROWS {
            self.alive = false
            return
        }
        if self.contains_snake(nh) {
            self.alive = false
            return
        }

        self.snake.push(nh)
        if nh.equals(self.food) {
            self.score += 1
            self.spawn_food()
        } else {
            self.snake.remove(0u64)
        }
    }
}

func draw_game(ctx: &gui.Context, game: &SnakeGame) {
    var board_w: i32 = COLS * CELL
    var board_h: i32 = ROWS * CELL

    gui.begin(ctx)
    gui.set_title(ctx, format("Yuan 贪吃蛇 - 分数 {}", game.score))
    gui.clear(ctx, gui.color_hex(COLOR_BG))

    gui.fill(ctx, gui.rect(BOARD_X - 2, BOARD_Y - 2, board_w + 4, board_h + 4), gui.color_hex(COLOR_TEXT))
    gui.fill(ctx, gui.rect(BOARD_X, BOARD_Y, board_w, board_h), gui.color_hex(COLOR_BOARD))
    gui.stroke(ctx, gui.rect(BOARD_X - 2, BOARD_Y - 2, board_w + 4, board_h + 4), gui.color_hex(COLOR_TEXT))
    gui.line(ctx, gui.point(BOARD_X, BOARD_Y - 12), gui.point(BOARD_X + board_w, BOARD_Y - 12), gui.color_hex(COLOR_TEXT))

    var i: usize = 0u64
    while i < game.snake.len {
        var p: Point = game.snake.get(i)
        var px: i32 = BOARD_X + p.x * CELL + 2
        var py: i32 = BOARD_Y + p.y * CELL + 2
        var cell_size: i32 = CELL - 4
        if i == game.snake.len - 1u64 {
            gui.fill(ctx, gui.rect(px, py, cell_size, cell_size), gui.color_hex(COLOR_HEAD))
        } else {
            gui.fill(ctx, gui.rect(px, py, cell_size, cell_size), gui.color_hex(COLOR_SNAKE))
        }
        i += 1u64
    }

    var fx: i32 = BOARD_X + game.food.x * CELL + 4
    var fy: i32 = BOARD_Y + game.food.y * CELL + 4
    gui.fill_disk(ctx, gui.circle(fx + (CELL - 8) / 2, fy + (CELL - 8) / 2, (CELL - 8) / 2), gui.color_hex(COLOR_FOOD))

    gui.text(ctx, gui.text_span(format("Yuan 贪吃蛇   分数：{}", game.score), BOARD_X, 18, gui.color_hex(COLOR_TEXT)))
    if game.alive {
        gui.text(ctx, gui.text_span("WASD/方向键移动，ESC 退出", BOARD_X + 240, 18, gui.color_hex(COLOR_TEXT)))
    } else {
        gui.text(ctx, gui.text_span("游戏结束 - 按 R 重新开始，ESC 退出", BOARD_X + 160, 18, gui.color_hex(COLOR_DANGER)))
    }

    gui.end(ctx)
}

func main() -> i32 {
    var window_w: i32 = BOARD_X * 2 + COLS * CELL
    var window_h: i32 = BOARD_Y + ROWS * CELL + 24
    var ctx: gui.Context = gui.open(gui.window_options(window_w, window_h, "Yuan 贪吃蛇（窗口版）"))! -> err {
        println("[snake-window] GUI 初始化失败：{}", err.message())
        return 1
    }
    defer gui.shutdown(&ctx)

    var seed: u64 = std.time.now_unix() as u64
    var game: SnakeGame = SnakeGame.create(seed)
    defer game.free()
    game.spawn_food()

    var tick_ns: i64 = 130000000i64
    var last_tick: i64 = @os_time_unix_nanos()

    loop {
        if gui.should_close(&ctx) {
            break
        }

        var input: gui.Input = gui.poll_input(&ctx)
        if input.quit() {
            break
        }

        if !game.alive && input.action() {
            seed = std.time.now_unix() as u64
            game.reset(seed)
            game.spawn_food()
            last_tick = @os_time_unix_nanos()
        }

        if input.up() {
            game.set_dir(DIR_UP)
        } elif input.right() {
            game.set_dir(DIR_RIGHT)
        } elif input.down() {
            game.set_dir(DIR_DOWN)
        } elif input.left() {
            game.set_dir(DIR_LEFT)
        }

        var now: i64 = @os_time_unix_nanos()
        if game.alive && (now - last_tick) >= tick_ns {
            game.step()
            last_tick = now
        }

        draw_game(&ctx, &game)
        gui.sleep_ms(&ctx, 300)
    }

    return 0
}
